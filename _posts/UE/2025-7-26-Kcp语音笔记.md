---
layout: post
title: "多人语音笔记"
date: 2021-8-20 09:00:00 +0800 
categories: UE
tag: Basic
---
* content
{:toc #markdown-toc}

这是一篇关于使用KCP开发多人语音笔记的文章

<!-- more -->

# 网络部分

## KCP协议教程

> 参考：[从入门到入魂！Linux中的kcp协议解析](https://zhuanlan.zhihu.com/p/551210324)
>
> 算法库：[kcp](https://github.com/skywind3000/kcp)

kcp其实就是一个算法，传输还是要靠UDP，并且经过kcp处理后包体会变大24字节。

> 注：在使用kcp时，`ikcp_update`要求传入一个时间，本来使用`CurrentTime = (FDateTime::UtcNow()-FDateTime(1970, 1, 1)).GetTotalMilliseconds();`在PC上运行正常，在安卓上运行时，他的slap一直等于-10，并且`kcp->ts_flush`无人更新导致`ikcp_flush(kcp);`无法被调用以至于kcp的output函数一直无法回调，最终我找到原因是安卓上没有实现`UtcNow`函数，最终我改用了`uint32 CurrentTime = FPlatformTime::Seconds()*1000;`

## switch块中定义临时变量

在C/C++的switch语句中，当遇到`default`标签时，如果其后紧跟着变量的定义和初始化，就会出现“default标签跳过初始化操作”的错误。

这是因为`switch`语句不允许在`case`或`default`标签后面直接定义和初始化变量。

为了解决这个问题，需要将变量的定义和初始化部分用花括号`{}`括起来，形成一个独立的局部作用域。使变量的作用域仅限于 `case/default` 分支内部，不会影响 `switch` 语句之外的代码。

## 在UObject中GetWorld为NULL的原因

> 需要补充知识：[UEGamePlay框架：WorldContext，GameInstance，Engine，UGameplayStatics](https://zhuanlan.zhihu.com/p/16084230887)

```c++
//错误：A = NewObject<A>();
A = NewObject<A>(this,TEXT("A"));//正确
```

在NewObject时，忘记传入**Outer**就会导致GetWorld中的Outer为空，无法得到World。

UObject 类会在引擎加载阶段，创建一个 Default Object 默认对象，这意味着：构造函数被调用时，UWord不一定存在，因此 GetWord() 返回值可能为空

## 虚幻引擎获取时间戳

全世界同一时刻生成的时间戳的值是相同的。是当前UTC时间 - UTC（1970.1.1 00:00:00）时间的差值，不存在时区的概念。不计算闰秒闰月（安卓无法使用）

```cpp
// 获取时间戳
const int64 timestamp = (FDateTime::UtcNow() - FDateTime(1970, 1, 1)).GetTotalMilliseconds();
```

## Protobuf使用

> 详见：[官方手册](https://protobuf.dev/programming-guides/proto3/)
>
> [libprotobuf](https://github.com/thejinchao/libprotobuf)
>
> [UE-Protobuf-Plugin](https://github.com/JGameEngine/UE-Protobuf-Plugin)

使用protobuf时，需要先根据应用需求编写 `.proto` 文件 定义消息体格式，例如：

```shell
syntax = "proto3";

option optimize_for = SPEED;

package Proto;

message GVoicePeer{
    int32 PeerID = 1;
    repeated int32 TeamID = 2;
}
```

其中，`syntax` 关键字表示使用的`Protobuf`的版本，如不指定则默认使用 `"proto2"`；`package`关键字 表示“包”，生成目标语言文件后对应C++中的`namespace`命名空间，用于防止不同的消息类型间的命名冲突。`message`类似C++中的结构体，`repeated`是数组声明（`syntax`单词字面含义：句法，句法规则，语构）

### proto文件中的 option 选项

.proto文件中的option选项用于配置protobuf编译后生成目标语言文件中的代码量，可设置为 `SPEED`， `CODE_SIZE`， `LITE_RUNTIME` 三种。
默认option选项为 SPEED，常用的选项为 LITE_RUNTIME。

**三者的区别在于：**

- SPEED（默认值）：
表示生成的代码运行效率高，但是由此生成的代码编译后会占用更多的空间。

- CODE_SIZE：
与SPEED恰恰相反，代码运行效率较低，但是由此生成的代码编译后会占用更少的空间，通常用于资源有限的平台，如Mobile。

- LITE_RUNTIME：
生成的代码执行效率高，同时生成代码编译后的所占用的空间也非常少。这是以牺牲Protobuf提供的反射功能为代价的。因此我们在C++中链接Protobuf库时仅需链接libprotobuf-lite，而非protobuf。

### 使用

#### 创建插件

首先在UE里创建一个C++的空插件，然后在Source文件夹中新建ThirdParty文件夹，然后将[libprotobuf](https://github.com/thejinchao/libprotobuf)拷贝进去。然后在Source文件夹中新建Protobuf文件夹，将`libprotobuf`模块添加到`Build.cs`中的`PrivateDependencyModuleNames`，在创建Protobuf模块类即可（在UE里创建插件这些一般都有了）。如果想要再继承一个可以UE里自动编译`.proto`的功能按钮，可以将[UE-Protobuf-Plugin](https://github.com/JGameEngine/UE-Protobuf-Plugin)中的ProtobufEditor文件夹拷贝到Source文件夹中，然后在`.uplugin`文件中的Modules添加`ProtobufEditor`，现在的应该是下面内容：

```xml
"Modules": [
    {
        "Name": "Protobuf",
        "Type": "Runtime",
        "LoadingPhase": "PreDefault"
    },
    {
        "Name": "ProtobufEditor",
        "Type": "Editor",
        "LoadingPhase": "Default"
    }
]
```

#### Protobuf工具使用

定义好 `.proto` 文件后放在protc.exe程序的同目录下，在此目录执行

```bash
.\protoc.exe -I . --cpp_out=../ ./*.proto

pause
```

执行完毕后会生成 `.h` `.cc` 两个文件放在工程中后引用即可使用

```c++
template<>
void SetProto(const FUserInfo& ProtoInfo, TArray<uint8>& OutBuffer)
{
    Proto::GVoicePeer VoicePeer;//定义protobuf结构体
    VoicePeer.set_peerid(ProtoInfo.UserID);
    for (int32 i = 0; i < ProtoInfo.TeamID.Num(); i++)//获取数组
    {
        VoicePeer.add_teamid(ProtoInfo.TeamID[i]);
    }

    void* Data = malloc(VoicePeer.ByteSizeLong());
    VoicePeer.SerializeToArray(Data, VoicePeer.ByteSizeLong());//序列化

    OutBuffer.Append(static_cast<uint8*>(Data), VoicePeer.ByteSizeLong());

    free(Data);
    Data = nullptr;
}
template<>
void GetProto(const TArray<uint8>& InBuffer, FUserInfo& OutProtoInfo)
{
    Proto::GVoicePeer VoicePeer;
    VoicePeer.ParseFromArray(InBuffer.GetData(), InBuffer.Num());//反序列化
    OutProtoInfo.UserID = VoicePeer.peerid();
    OutProtoInfo.TeamID.Append(VoicePeer.teamid().data(), VoicePeer.teamid().size());
}
```

> 注：编译的时候`.pb.cc`文件可能产生`C4800`的错误，使用`#pragma warning(disable: 4800)`禁用即可
>

## FLogCategory

在使用自定义`LogCategory`时遇到一个问题，我声明一个EXTERN的`LogCategory`，并且在另外一个模块中使用，出现两个问题：

1，在另外一个模块中的`.cpp`文件使用`DEFINE_LOG_CATEGORY`定义，在打包时出现如下问题

```cmake
Log          UATHelper                 Packaging (Windows): MyAudioCapComponent.cpp.obj : error LNK2005: "struct FLogCategoryLogRuntimeAudioImporter LogRuntimeAudioImporter" (?LogRuntimeAudioImporter@@3UFLogCategoryLogRuntimeAudioImporter@@A) 已经在 RuntimeAudioImporter.cpp.obj 中定义
Log          UATHelper                 Packaging (Windows): D:\UEProjects\AudioCaptureTest\Binaries\Win64\AudioCaptureTest.exe : fatal error LNK1169: 找到一个或多个多重定义的符号
```
2，在另外一个模块中的`.cpp`文件使用不使用`DEFINE_LOG_CATEGORY`定义，在编译时出现如下问题

```ABAP
11>MyAudioCapComponent.cpp.obj: Error LNK2001 : 无法解析的外部符号 "struct FLogCategoryLogRuntimeAudioImporter LogRuntimeAudioImporter" (?LogRuntimeAudioImporter@@3UFLogCategoryLogRuntimeAudioImporter@@A)
11>UnrealEditor-AudioCaptureTest.dll: Error LNK1120 : 1 个无法解析的外部命令
```

### 解决方法

这个问题之前也说过，想使用另一个模块的东西需要将他暴露给模块外，使用该模块名大写加上`_API`就行，比如

```c++
// CoreGlobals.h
CORE_API DECLARE_LOG_CATEGORY_EXTERN(LogTemp, Log, All);
// CoreGlobals.cpp
DEFINE_LOG_CATEGORY(LogTemp);
```

## UE编译日志乱码

> 参考：[Unreal Engine 4：编译时出现中文乱码问题](https://blog.csdn.net/netyeaxi/article/details/81206896)

log在UE中是从一个本地语言编码（GBK编码）的Buffer中取出，我们可以有几种办法解决乱码问题：

### 1、使用UTF-8提供全球语言支持

打开`控制面板`，点击`时钟和区域`，点击`区域`，在弹出的区域面板中选择`管理`，在下面的非Unicode程序的语言中点击`更改系统区域设置`，勾选`Beta版：使用UnicodeUTF-8提供全球语言支持`，点击确定并重启。

### 2、修改UE内的源文件

#### 分析

下面来分析一下中文乱码的产生原因。

经分析Output Log，可以发现产生乱码的原因之一是调用了UnrealBuildTool.exe后产生的。经查找代码，UnrealBuildTool.exe是在Engine\Source\Developer\DesktopPlatform\Private\Windows\DesktopPlatformWindows.cpp的如下方法中被调用的：

```cpp
bool FDesktopPlatformWindows::RunUnrealBuildTool(const FText& Description, const FString& RootDir, const FString& Arguments, FFeedbackContext* Warn)
```

在此方法中调用了

```cpp
bool FFeedbackContextMarkup::PipeProcessOutput(const FText& Description, const FString& URL, const FString& Params, FFeedbackContext* Warn, int32* OutExitCode)
```

此方法使用了

```cpp
FPlatformProcess::ReadPipe(PipeRead);
```

来读取返回的结果，其代码如下：

```cpp
FString FWindowsPlatformProcess::ReadPipe( void* ReadPipe )
{
    FString Output;
 
    uint32 BytesAvailable = 0;
    if (::PeekNamedPipe(ReadPipe, NULL, 0, NULL, (::DWORD*)&BytesAvailable, NULL) && (BytesAvailable > 0))
    {
        UTF8CHAR* Buffer = new UTF8CHAR[BytesAvailable + 1];
        uint32 BytesRead = 0;
        if (::ReadFile(ReadPipe, Buffer, BytesAvailable, (::DWORD*)&BytesRead, NULL))
        {
            if (BytesRead > 0)
            {
                Buffer[BytesRead] = '\0';
                Output += FUTF8ToTCHAR((const ANSICHAR*)Buffer).Get();    //#1
            }
        }
        delete [] Buffer;
    }
 
    return Output;
}
```

从`#1`这行代码中可以看到，存储返回结果的Buffer被当成UTF-8编码的字符串转换成FString，而实际上在默认中文windows中，它应该是GBK编码的。产生乱码的原因就在此处。这也是为什么采用“解决方法一”能够解决问题的原因，因为“解决方法一”可以返回UTF-8编码的结果。


通过上述分析，也自然而然有了此解决方法

#### 解决办法

将FWindowsPlatformProcess中的#1处修改了：

```cpp
Output += FString(string2wstring(std::string((const ANSICHAR*)Buffer), "Chinese_China.936").c_str());
```

即先把GBK编码的Buffer转化成std::wstring，然后再转换成FString。当然，这样需要重新编译unreal。这个方法我没试过，不过应该生效。

------

 另外，需要说明一下UnrealBuildTool.exe，它是由C#编写的，代码在Epic Games\UE_4.18\Engine\Source\Programs\UnrealBuildTool下。它会在LocalExecutor.cs文件中的ThreadFunc()方法中，分别调用如下三个命令：

```cobol
{C:\Microsoft\Visual Studio\2017\Professional\VC\Tools\MSVC\14.13.26128\bin\HostX64\x64\cl.exe -  @"D:\unreal_projects\CrazyTanx\Intermediate\Build\Win64\UE4Editor\Development\CrazyTanx\Conf.cpp.obj.response"}

{C:\Microsoft\Visual Studio\2017\Professional\VC\Tools\MSVC\14.13.26128\bin\HostX64\x64\link.exe - @"D:\unreal_projects\CrazyTanx\Intermediate\Build\Win64\UE4Editor\Development\UE4Editor-CrazyTanx.dll.response"}

{C:\Microsoft\Visual Studio\2017\Professional\VC\Tools\MSVC\14.13.26128\bin\HostX64\x64\lib.exe - @"D:\unreal_projects\CrazyTanx\Intermediate\Build\Win64\UE4Editor\Development\UE4Editor-CrazyTanx.lib.response"}
```

并将执行结果返回给UnrealBuildTool.exe，再由UnrealBuildTool.exe将结果返回给UE4Editor.exe，UE4Editor.exe会将此结果显示在Output Log窗口，乱码就是在UnrealBuildTool.exe将结果返回给UE4Editor.exe时产生的。

## FRunnable与静态变量

我将FRunnable对象做成了单例持有一个static的自己类型变量大致结构如下：

```c++
FRunnableClient* FRunnableClient::Instance = nullptr;

FRunnableClient::FRunnableClient()
	: bRunning(true)
{
	Thread = FRunnableThread::Create(this, TEXT("RunnableClientThread"));
}

FRunnableClient::~FRunnableClient()
{
	if (Thread)
	{
		Thread->Kill(true);//终止此线程，线程结束，下面程序就停止了，这也是跑在FRunnableClient线程里面的
		
		delete Thread;
		Thread = nullptr;
	}
	Instance = nullptr;
}
void FRunnableClient::CreateThread()
{
	if(!Instance)
	{
		Instance = new FRunnableClient();
	}
}
void FRunnableClient::Exit()
{
	if(Instance)
	{
		delete Instance;//delete后销毁线程，下面程序就停止了，这都是跑在FRunnableClient线程里面的
        
		Instance = nullptr;
	}
}
```

然后就会有错误，第二次运行的时候发现Instance没被设为nullptr，导致线程无法创建，究其原因，在我外部调用Stop函数后线程将运行Exit函数，之后执行`delete Instance`会在此线程调用析构函数，在析构函数中`Thread->Kill(true)`线程终止，`Instance = nullptr`无法达到，所以第二次运行判空不成功。之后我新建一个函数让外部调用，不能直接调用Stop函数

```c++
void FKcpSocketThread::StopThread()
{
    Stop();
    if(Thread)
    {
       Thread->Kill(true);
    }
    if(Instance)
    {
        delete Instance;
        Instance = nullptr;
    }
}
```

## 获得枚举值对应的字符串

> 参考：[在UE中获得枚举(UEnum)值对应的字符串](https://blog.csdn.net/u013412391/article/details/121441199)

```c++
UENUM()
enum class EMsgCode : int
{
    CODE_HEART = 1000		UMETA(DisplayName="Heart"),
    CODE_HEART_RET = 1001,
};
```

首先枚举类型要被`UENUM()`标记

然后可以

```c++
FindObject<UEnum>(nullptr, TEXT("/Script/MyModule.EMsgCode"))->GetNameStringByValue(1000);	//"CODE_HEART"
```

如果获得对应的显示名（DisplayName）则需要把 `GetNameStringByValue` 换为 `GetMetaData(TEXT("DisplayName"), value)`。即：

```c++
FindObject<UEnum>(nullptr, TEXT("/Script/AudioCaptureTest.EVoiceMsgCode"))->GetMetaData(TEXT("DisplayName"), 1000);	//"Heart"
```

> 注：不过这个使用了UObject系统，虽然绝大多数可以使用，不过一些更底层的没有依赖`CoreUObject`模块，因此需要看看能不能加上并包括`#include "Runtime/CoreUObject/Public/UObject/UObjectGlobals.h"`，因为`FindObject`函数在其中定义。

## C++接口

> 参考：[接口](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/interfaces-in-unreal-engine)
>
> [MustImplement](https://github.com/fjz13/UnrealSpecifiers/blob/main/Doc/zh/Meta/TypePicker/MustImplement/MustImplement.md)

我在写代码时有一个输入接口类型和输出接口类型的Object的需求，然后写了这样一个函数

```c++
UFUNCTION(BlueprintCallable, Category = "E", meta=(AdvancedDisplay=5))
TScriptInterface<class IMyInterface> Foo(const FString& A, int32 B, int32 C, FString& D,
    UPARAM(meta=(MustImplement="MyInterface")) TSubclassOf<UObject> InterfaceType);
```

首先，如果返回 `IMyInterface*` 会报错，因为我实例化的是继承了`IMyInterface`的子类，而子类是`UObject`的类型的，因此需要用`TScriptInterface`将他包裹，return时会隐式转换，并且蓝图节点可视。

第二，我需要用户选择`InterfaceType`，但是`TSubclassOf`不支持接口类，或许你可以通过继承`TSubclassOf`实现一个给接口使用的，但是更为简单的是使用`UPARAM`宏并使用`meta=(MustImplement="")`，这样在蓝图节点中可用的选项就只有实现了接口的类了（当然，类需要继承自`UObject`及其子类）。

第三，我想使用延迟推导返回类型，来直接返回所选的类的Object或者使用模板返回Object，这样蓝图就不需要再`Cast`到所选类了，但是蓝图不支持这两种办法。

<p style="color:red">注：K2Node有可能实现，可参考lyra中GameplayMessageRouter</p>

## 蓝图委托

Dynamic委托提供可序列化和反射的功能，如果想要在蓝图中为委托绑定还需要`BlueprintAssignable`标识符，此标识符只支持Multicast委托，如果还想让蓝图去多播这个委托就还需要`BlueprintCallable`标识符

## 网络解耦方法

> 参考：[通信层与业务层分离的解耦传输方法及系统](https://patents.google.com/patent/CN112261037A/zh)

![](D:\WindCrazyGithubio\windcrazy123.github.io\styles\images\Other\网络结构.png)

现在大致为类似这样一个结构，我需要一个服务就创建一个实现一个通用接口，而通信层只与接口交互将收的消息和发的消息处理完协议后通过UDP发送

## C++存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。

- **auto**：这是默认的存储类说明符，通常可以省略不写。auto 指定的变量具有自动存储期，即它们的生命周期仅限于定义它们的块（block）。auto 变量通常在栈上分配。
- **register**：用于建议编译器将变量存储在CPU寄存器中以提高访问速度。在 C++11 及以后的版本中，register 已经是一个废弃的特性，不再具有实际作用。
- **static**：用于定义具有静态存储期的变量或函数，它们的生命周期贯穿整个程序的运行期。在函数内部，static变量的值在函数调用之间保持不变。在文件内部或全局作用域，static变量具有内部链接，只能在定义它们的文件中访问。
- **extern**：用于声明具有外部链接的变量或函数，它们可以在多个文件之间共享。默认情况下，全局变量和函数具有 extern 存储类。在一个文件中使用extern声明另一个文件中定义的全局变量或函数，可以实现跨文件共享。
- **mutable (C++11)**：用于修饰类中的成员变量，允许在const成员函数中修改这些变量的值。通常用于缓存或计数器等需要在const上下文中修改的数据。
- **thread_local (C++11)**：用于定义具有线程局部存储期的变量，每个线程都有自己的独立副本。线程局部变量的生命周期与线程的生命周期相同。

从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。
存储类说明符为程序员提供了控制变量和函数生命周期及可见性的手段。
合理使用存储类说明符可以提高程序的可维护性和性能。
从 C++11 开始，register 已经失去了原有的作用，而 mutable 和 thread_local 则是新引入的特性，用于解决特定的编程问题。

------

在了解什么是存储类后，需要注意的是在写模板函数时，特化的函数不能带有存储类说明符比如：

```c++
template<typename T>
static void SetProto(const T& ProtoInfo, TArray<uint8>& OutBuffer)
{
    //...
}
template<>
void SetProto(const FUserInfo& ProtoInfo, TArray<uint8>& OutBuffer)
{
    //...
}
```

如果写成

```c++
template<>
static void SetProto<FUserInfo>(const FUserInfo& ProtoInfo, TArray<uint8>& OutBuffer)
{
    //...
}
```

会出现这样的警告

```ABAP
Error C4499 : “static”: 显式专用化不能具有存储类(忽略)
```

# 语音部分

如何进行语音聊天，通过查找资料([Initial VoiceModuleAndroid support](https://github.com/EpicGames/UnrealEngine/pull/2894))找到最开始将支持安卓语音聊天的请求，他在 Android 上运行 libOpus（适用于 Win、Mac 和 Linux，更新后支持Android。可以在 `Engine/Source/ThirdParty/libOpus` 中找到它）。我们可以看到`FVoiceCaptureOpenSLES`继承于`IVoiceCapture`，此接口有一个函数`GetVoiceData`，此后我们将使用此函数来获取捕获的音频，有`Start`和`Stop`来开启和关闭功能。接下来就通过`VoiceCapture = FVoiceModule::Get().CreateVoiceCapture("");// 单声道`来获取实现`IVoiceCapture`接口的语音捕获设备。那么到此语音捕获就完成了。

语音序列化的内容得到了那么如何解析呢。通过访问[如何可靠地访问 USoundWave PCM 数据（使用或不使用 FAsyncAudioDecompress）](https://forums.unrealengine.com/t/how-to-reliably-access-usoundwave-pcm-data-with-or-without-fasyncaudiodecompress/444631)了解到`GeneratePCMData`函数我们可以通过`USoundWaveProcedural`来进行输入音频数据并播放

## 安卓请求权限

首先是麦克风权限的问题

如果不做这个操作会在log中看到这些东西

```less
[2025.08.01-02.26.25:849][320]LogVoiceCapture: Warning: VoiceModuleAndroid Init
[2025.08.01-02.26.25:849][320]LogAndroidPermission: UAndroidPermissionFunctionLibrary::CheckPermission android.permission.RECORD_AUDIO (Android)
[2025.08.01-02.26.25:850][320]LogVoiceCapture: Warning: ANDROID PERMISSION: RECORD_AUDIO is not granted.
[2025.08.01-02.26.25:850][320]LogVoiceCapture: Warning: Trying to free unknown voice object
[2025.08.01-02.26.25:850][320]LogTemp: Error: Failed to start voice capture
```

在Project Setting中Platforms-Android下在Advanced APK Packaging中勾选Add permissions to support Voice chat (RECORD_AUDIO)和Request permission at startup for Voice chat (RECORD_AUDIO)

![](D:\WindCrazyGithubio\windcrazy123.github.io\styles\images\Other\MicrophonePermission.png)

请求成功后会看到

```less
[2025.08.01-03.29.50:687][298]LogVoiceCapture: Warning: VoiceModuleAndroid Init
[2025.08.01-03.29.50:688][298]LogAndroidPermission: UAndroidPermissionFunctionLibrary::CheckPermission android.permission.RECORD_AUDIO (Android)
[2025.08.01-03.29.50:690][298]LogVoiceCapture: Warning: OpenSLES Initializing HW
[2025.08.01-03.29.50:690][298]LogVoiceCapture: Warning: Create audio recorder
[2025.08.01-03.29.50:703][298]LogVoiceCapture: Warning: OpenSLES SL_RecorderBufferQueue -1903600784
[2025.08.01-03.29.50:709][298]LogTemp: Voice capture started
```

但是Request permission at startup for Voice chat (RECORD_AUDIO)是在开始捕获时才请求，并没有异步回调，因此第一次运行会因为检测到没有权限而失败，在第一次运行时你同意权限后，之后运行就会请求成功并开始捕获，因此建议在捕获前请求权限

```c++
#if PLATFORM_ANDROID
#include "AndroidPermissionFunctionLibrary.h"
#include "AndroidPermissionCallbackProxy.h"

bool UVoiceCaptureComponent::StartVoiceCapture()
{
    // 检查并请求权限
    TArray<FString> Permissions = { "android.permission.RECORD_AUDIO" };
    
    if (!UAndroidPermissionFunctionLibrary::CheckPermission(Permissions[0]))
    {
        UAndroidPermissionFunctionLibrary::AcquirePermissions(Permissions);
        return false;
    }
    
    // 原有启动代码...
}
#endif
```

接下来就是网络的问题

在调用kcp对象的send方法时没有接收到他的output回调

```less
[2025.08.01-03.29.49:645][204]LogSockets: Warning: Failed to acquire WifiManager.MulticastLock. Is multicast/broadcast support for Android enabled in AndroidRuntimeSettings?
```

