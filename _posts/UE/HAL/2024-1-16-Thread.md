---
layout: post
title: "Thread"
date: 2024-1-16 09:00:00 +0800 
categories: UE
tag: HAL
---
* content
{:toc #markdown-toc}

一些关于UE的Thread的知识

<!-- more -->





# 注意

## What Not to Do不该做什么

- 不要尝试在其他线程修改、创建或删除 UObject！

您可以准备所有数据/执行所有计算，但只有游戏线程应该实际生成/修改/删除 UObjects/AActors。

- Dont try to use TimerManager outside of the game thread 😃不要尝试在游戏线程之外使用 TimerManager 😃
- Don't try to draw debug lines/points etc, as it will likely crash, ie DrawDebugLine(etc...)不要尝试绘制调试线/点等，因为它可能会崩溃，即 DrawDebugLine(etc...)

Notice (since 4.11):注意（自4.11起）：

If you want to use the timer, remove, and modify variables use it:如果您想使用计时器、删除和修改变量，请使用它：

\#include "Async.h" ... AsyncTask(ENamedThreads::GameThread, []() { // code to execute on game thread here });#include“异步.h” ... AsyncTask(ENamedThreads::GameThread, []() { // 在游戏线程上执行的代码 });

# 遇到的问题

## 另一个线程使用引用捕获失败

问题描述：UE中使用runnable创建出来的线程里使用AsyncTask(ENamedThreads::Type::GameThread,\[Location,Rotation,this\](){}可以捕获Location和Rotation但是如果使用引用捕获则不行，这是为什么

```c++
//当前线程：Runnable的线程
FVector Location = FVector(lon,lat,alt);
FRotator Rotation = FRotator(pitch,heading,roll);
AsyncTask(ENamedThreads::Type::GameThread,[/*&*/Location,/*&*/Rotation,this]()
{
    UE_LOG(LogTemp,Warning,TEXT("%f"),Location.X);
    if (!OnReceiveSyncTrans.ExecuteIfBound(Location, Rotation))
    {
       UE_LOG(LogTemp,Warning,TEXT("OnReceiveSyncTrans not execute"));
    }
});
```

<font color=yellow>使用引用捕获Location和Rotation可能会导致问题。因为在创建Lambda表达式时，Location和Rotation可能已经超出了它们的作用域，在Lambda执行时可能找不到这些变量的有效引用。这就是为什么引用捕获Location和Rotation可能会导致问题的原因。</font>

<font color=yellow>超出作用域后Location和Rotation的生命周期结束，导致无效，而this关键字默认是以引用的方式捕获的，因此在Lambda中可以访问this指针所指向的对象的成员变量和成员函数。</font>**悬垂引用：**若以引用隐式或显式捕获非引用实体，而在该实体的生存期结束之后调用lambda对象的函数调用运算符，则发生未定义行为。C++ 的闭包并不延长被捕获的引用的生存期。这同样适用于被捕获的this指针所指向的对象的生存期。<font color=yellow>因此，在使用this捕获的情况下，需要确保Lambda的执行发生在this指向的对象的有效生命周期内。</font>

# 获取当前线程ID和名字

每个线程都有一个线程ID，线程ID在它所属的进程环境中有效。为增加标识性，UE4还增加了线程名称。线程ID是唯一的，线程名称可以重复。可通过`GetThreadID`和 `GetThreadName` 获取线程ID和名称。

```c++
uint32 CurrentThreadId = FPlatformTLS::GetCurrentThreadId();
FString CurrentThreadName = FThreadManager::Get().GetThreadName(CurrentThreadId);
```

# FRunnable的使用

> 参考：[UE4多线程FRunnable](https://zhuanlan.zhihu.com/p/571515841)

FRunnable是UE4中多线程的实现方式之一，适用于复杂运算。

FRunnable需要依附与一个`FRunnableThread`对象，才能被执行。

1. FRunnableThread通过FRunnableThread::Create来调用对应平台的接口来创建线程，并调用 FRunnable 对象的Init，Run等事件。Create执行之后，对应的线程函数Run立即执行，并没有Start之类的方法。
2. FRunnable定义了Init()，Run()，Exit()等虚函数，首先执行Init，初始化完成后执行Run，Run执行完毕之后执行Exit。
   主动调用Stop，可以提前终止线程。
3. 如果要结束线程，可以调用FRunnableThread的Kill方法。Kill方法仅仅调用了RunnableObject的Stop方法(既然你已经拿到了RunnableObject，就直接调用Stop方法即可)，因此需要手动在Stop方法中将退出信息传递给Run函数，从而结束Run方法。

```c++
class FMyRunnable : public FRunnable
{
protected:
    // FRunnable interface
    virtual bool Init() override;// 初始化 runnable 对象，在FRunnableThread创建线程对象后调用
    virtual uint32 Run() override;// Runnable 对象逻辑处理主体，在Init成功后调用
    virtual void Stop() override;// 停止 runnable 对象, 线程提前终止时被用户调用 如：Kill()或直接调用Stop()
    virtual void Exit() override;// 退出 runnable 对象，由FRunnableThread调用，在Run函数return后会调用此函数。
    // ~FRunnable interface

private:
	FRunnableThread* Thread;
	FThreadSafeBool bRunning;
}
```

```c++
//D:\UE_5.4\Engine\Source\Runtime\Core\Private\Windows\WindowsRunnableThread.cpp 用Windows平台举例
uint32 FRunnableThreadWin::Run()
{
    uint32 ExitCode = 1;
    check(Runnable);

    if (Runnable->Init() == true)	//初始化 runnable 对象，在FRunnableThread创建线程对象后调用
    {
       ThreadInitSyncEvent->Trigger();

       SetTls();

       ExitCode = Runnable->Run();	// Runnable 对象逻辑处理主体，在Init成功后调用

       Runnable->Exit();			// 退出 runnable 对象，由FRunnableThread调用

#if STATS
       FThreadStats::Shutdown();
#endif
       FreeTls();
    }
    else
    {
       ThreadInitSyncEvent->Trigger();
    }

    return ExitCode;
}
```

## 获取线程名字

FRunnable有自己的获取名字和ID的方法需要通过FRunnableThread调用

```c++
Thread->GetThreadName();
```

当然通过`FThreadManager`仍然是可以的，因为通过FRunnableThread 创建的线程是通过`FThreadManager`进行统一管理。

```c++
FThreadManager::Get().AddThread(ThisThread->GetThreadID(), ThisThread);
```



> 多线程教程链接：[【UE·引擎篇】Runnable、TaskGraph、AsyncTask、Async多线程开发指南](https://blog.csdn.net/j756915370/article/details/122752719)
>
> [《Exploring in UE4》多线程机制详解(原理分析) ](https://zhuanlan.zhihu.com/p/38881269)
>
> [UE4/UE5的TaskGraph](https://cloud.tencent.com/developer/article/1897046)
>
> [b站：【合集】UE4 C++进阶(进行中)](https://www.bilibili.com/video/BV14p4y1a7nj?p=7)
>
> [2w字 + 40张图带你参透并发编程！ ](https://www.cnblogs.com/cxuanBlog/p/13523033.html)

# 参考链接

> 1，[Multi-Threading: How to Create Threads in UE4](https://michaeljcole.github.io/wiki.unrealengine.com/Multi-Threading:_How_to_Create_Threads_in_UE4)
>
> 2，[UE 多线程](https://blog.csdn.net/qq_52825422/article/details/133884930)
>
> 3，[UE4多线程FRunnable](https://zhuanlan.zhihu.com/p/571515841)
