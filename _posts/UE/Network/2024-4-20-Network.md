---
layout: post
title: "联网和多人游戏"
date: 2024-4-20 09:00:00 +0800 
categories: UE
tag: Network
---
* content
{:toc #markdown-toc}

这是一篇关于UE中网络知识的文章。虚幻引擎提供的网络框架非常的强大，在简化开发者的打造网络功能流程的同时，也增加了使用的负担，但是只要我们去了解和学习，这些负担终究会变为我们站在高处的基石。

<!-- more -->

> 参考：[UE官方文档：联网和多人游戏](https://docs.unrealengine.com/4.26/zh-CN/InteractiveExperiences/Networking/)

# 一、尽早规划多人游戏

和官方文档一样，这个真的很重要，第一步就是要在项目规划时就确定好是否需要有多人游戏功能，因为在这之后构建出来的gameplay框架(可能用词不准)几乎是两种完全不同的，我就亲眼看到过一个经验不充足的开发者，在上架一个单人射击游戏后，想要加入联机功能，他在整理整个项目之后告诉我说做不出来，因为这几乎要把整个项目重新写一遍并添加新的功能。如果你真的不太清楚，那么最好是构建有网络框架的gameplay，这样即便后面不需要联机功能，也可以运行。

# 二、开始多人游戏

有些开发者喜欢先做出一些功能再深入了解，说这样脑子里有自己的印象，比直接看概念好。但是我还是要在简单的开始前说什么是多人游戏。

## 1、什么是网络多人游戏

在单人游戏中，即使你用同一台计算机多个设备输入将游戏分屏进行本地多人游戏，这种游戏不需要联网将信息传输到另一台机器上运行游戏实例，所有交互都在同一台机器上的同一场景中发生。

因此我们要说的多人游戏，是指真正的多人游戏，是网络多人游戏，他的交互发生在多个不同场景：服务器上的场景、玩家1客户端的场景、玩家2客户端的场景，等等。每台不同机器上的各场景均有各自的Actor副本。而服务器是游戏真正运行的地方，但我们要让客户端的场景看似发生了相同事件，比如：玩家1向前走了一步。因此，需要选择性地向各客户端发送信息，比如：有关玩家1移动的信息必须发送到玩家2的设备上，而玩家2也向前走了一步，那么我们也必须将玩家2移动的信息发送给玩家1的设备上。

<span id="TestMuti">那么</span>好，先在UE上看看多人游戏模式吧：[测试多人游戏](https://docs.unrealengine.com/4.26/zh-CN/InteractiveExperiences/Networking/TestMultiplayer/), [测试和调试网络游戏](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/testing-and-debugging-networked-games-in-unreal-engine?application_version=5.3)

## 2、测试多人游戏

 一方面可以先有一个小操作使读者有一个大概的印象，另一方面则是我们开发多人游戏时需要时不时的调试多人功能，如果每次都要先和其他开发者同步代码再联机测试未免有些太过繁琐，那么这里就有几种在本地进行多人游戏调试的方法。

### 1)启动独立服务器

**编辑器偏好设置(Editor Preferences)** > **关卡编辑器(Level Editor)** > **运行(Play)** > **多人游戏选项(Multiplayer Options)** > **启动独立服务器(Launch Independent Server)**设为`true`，**运行网络模式(Play Net Mode)** 选择**独立运行(Play Standalone)**，然后你找到**服务器端口(Server Port)**一般默认是`17777`这个你不需要改，然后找到**客户端玩家数量(Play Number Of Clients)**修改为`2`，你也可以尝试3或者以上的数值。ok配置完毕，这时你随意打开一个蓝图，点击运行按钮或者使用快捷键Alt+P，那么这个时候会弹出两个窗口，注意窗口上方的字你会发现有些不同，没错，一个是`Standalone 1`，一个是`Standalone 2`，这是两个独立运行的客户端，分别在命令行输入

```
open 127.0.0.1:17777
```

这时两个客户端就相见了，你可以跳一跳玩一玩。

![](../../../styles/images/Network/IndependentServer.png)

### 2)Play As Listen Server

现在我们将上述的启动独立服务器(Launch Independent Server)设为`false`，随意打开一个蓝图点击运行按钮旁边的三个点或下拉箭头，将下面的`Net Mode`设为`Play As Listen Server`，客户端数量还是2，现在点击运行。此时出现的两个客户端一个作为服务器`Server 0`，另一个则是客户端`Client 1`，哎，那么你就会问了，这个怎么是从0开始的，刚才那个怎么是从1开始的，因为上面那个还有一个你看不见的独立服务器在运行。

![](../../../styles/images/Network/PlayAsListenServer.png)

### 3)Play as Client

将Net Mode设为Play as Client运行一下看看，没错有一个隐藏服务器在运行，使用这个方法和第一种是一样的，只不过这个是自动的，按照官方说法，在编辑器的**网络模式选项（Net Mode options）**中使用**作为客户端运行（Play as Client）**或**作为侦听服务器运行（Play As Listen Server）**时，这些实例会自动通过IP地址直接相互连接。这相当于在**客户端**上运行 `open 127.0.0.1:17777` 命令，以便连接到服务器**。所以我们一般使用第2，3种方法测试，不用第一种。

### 4)Standalone Game

这个比较重要，因为在编辑器中运行（PIE）时，[服务器/客户端移动](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/travelling-in-multiplayer-in-unreal-engine?application_version=5.3)等功能存在限制。你的项目需要在独立模式下作为编辑器之外的单独进程运行，以便测试这些功能。

如果你在单独的进程下运行实例，一个实例将被视为在编辑器中运行，而其他实例将被视为独立运行。与统一运行实例相比，不论是统一在编辑器中运行还是统一独立运行，单独运行可能会导致不同的行为。例如，需要调用UEditorEngine::NetworkRemapPath函数，以便在通过网络发送的静态Actor的路径上添加或删除PIE前缀。

所以说如果某些功能在PIE中看不到，但是你感觉没问题那么就试试这个模式，可能就有效果了。

最后再看一下官方给出的[网络模式](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#networkmodes)图表

| **网络模式**       | `ENetMode`           | **说明**                                                 |
| :----------------------: | -------------------- | -------------------------------------------------- |
| **单机**          | `NM_Standalone`      | 有一个或多个本地玩家且没有联网的游戏。仍被视为服务器，因为它包含所有服务器功能，但不接受来自远程客户端的连接。此模式用于单人和本地多人游戏。此模式可根据需要同时运行服务器端和客户端逻辑。 |
| **专用服务器**     | `NM_DedicatedServer` | 没有本地玩家的服务器。服务器仅接受来自远程客户端的连接，因此为了更高效地运行，服务器放弃了图形、声音、输入和其他面向玩家的功能。此模式常用于需要更持久、安全或大规模多玩家的游戏。 |
| **监听服务器**     | `NM_ListenServer`    | 此服务器也有一个本地玩家，此玩家负责托管游戏。可供网络上的其他玩家链接。此模式常用于临时合作和竞技多人游戏。 |
| **客户端**        | `NM_Client`          | 连接到远程服务器的客户端。客户端连接到网络多人游戏会话中的监听服务器或专用服务器。客户端不运行服务器端逻辑。 |

# 三、网络概述

热身到这里想必你应该有一定的概念了，或许你还有好多疑惑，但是先从理论开始吧。[虚幻引擎网络架构](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#unrealenginenetworkingarchitecture)

## 1、网络架构

> 参考：[Game server](https://en.wikipedia.org/wiki/Game_server)

这里就开始讲解单独运行的游戏之间在网络中通信获取信息的方法。我们会讲解两种模型：对等模型(PEER-TO-PEER \ P2P)，客户端服务器模型(CLIENT-SERVER model \ C/S model)。

### 1)PEER-TO-PEER

> 参考：[Peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer)

这个是传输信息最简单的方法之一，当玩家1移动角色时，该动作信息将直接发送给玩家2的电脑，同样玩家2移动时，也会将信息发送给玩家1，这个听起来就很好实现，但是他有一些问题，现在我们有玩家3加入游戏，每当一个玩家移动时他们都必须将这些信息发送给其他两个玩家，这样会导致有大量的网络数据传输，对于拥有很多玩家的游戏，这听起来很差。

![](../../../styles/images/Network/P2P.png)

另外这么多人的游戏实例，没有权威的版本，每个都不同，每当玩家改动任一数据，比如走一步，就会偏离本地版本的游戏，其他机器需要一定时间传播接受数据来更新游戏实例，但是谁是真正的正确的游戏实例，没人知道。

### 2)CLIENT-SERVER

> 参考：[Client-server model](https://en.wikipedia.org/wiki/Client%E2%80%93server_model)

制作多人游戏还有一种方法，这种方法也是UE使用的架构，叫做**客户端-服务器架构**，很多玩家使用不同的计算机通过网络连接到一台中央计算机。中央计算机称为**服务器**，它会托管多人游戏，而不同计算机上的其他所有玩家都作为**客户端**连接到该服务器。服务器会将游戏状态信息与每个连接的客户端共享，并为不同计算机上的所有玩家提供了彼此通信的方式。每个客户端都只会与服务器交流，因此每个客户端只需要满足发送和接收自己的信息的宽带要求即可。举个栗子：玩家1移动一步，此信息发送给服务器，服务器发送给其他客户端，这样所有人的屏幕都会更新到玩家1移动了一步。

![](../../../styles/images/Network/ClientServer.png)
[^1]: *在联网多人游戏中，游戏将在服务器与多个与之连接的客户端之间进行。服务器处理Gameplay，客户端为用户渲染游戏。*

另外UE将服务器作为游戏主机保存一个真正的**权威**游戏状态。即：使用**Authoritative Client-Server Model**，权威客户端服务器架构。(当然实现C/S并不只有这一种方法)。换句话说，服务器是多人游戏实际运行的地方，并且服务器版本是权威版本被视为唯一正确的版本。客户端各自控制它们在服务器上拥有的远程**Pawn**。客户端从其本地Pawn向其服务器Pawn发送*远程程序调用*以在游戏中执行操作。接着，服务器向每个客户端*复制*关于游戏状态的信息，例如**Actor**所在的位置，这些Actor应该具备怎样的行为，以及不同的变量应该有哪些值。然后每个客户端使用这些信息，近似模拟服务器上实际正在发生的情况。所以其实情况是这样的：玩家1按下前进按钮进行移动，实际上将移动请求发送到服务器，然后检测以确保该运动合理，然后服务器移动角色并将移动更新信息再发给所有客户端包括玩家1，从服务器到客户端的数据分发称为**复制**。当然还有一些其他细节，后面再说。

> 默认情况下，服务器不会直接将视觉效果流送到客户端显示器进行显示，服务器会将状态信息发送给客户端游戏实例，以便客户端计算机可以在自己的游戏实例中重现视觉效果。虚幻引擎提供了 **像素流送（Pixel Streaming）** 系统，用于预渲染帧和音频，以在移动端和Web浏览器上显示。更多信息请参阅[像素流送](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/pixel-streaming-in-unreal-engine?application_version=5.3)文档。
>
> 复制详情参阅：[网络概述|复制](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#replication)

要实现这种权威客户端服务器模型，并不只有一种方法，比如：

- 监听服务器
  也叫Listen-server，这种情况下，有其中一个客户端充当服务器，那么此服务器实际上正在玩游戏并且会将图像渲染到屏幕上，监听服务器的优势在于它基本上是免费的，不需要任何特殊的基础设施或提前规划即可建立，不过由于运行服务器的机器也在生成输出图像，因此性能也会降低。此外，监听服务器为直接在其上玩游戏的玩家提供了比其他作为客户端的玩家更大的延迟优势，并且当该玩家离开游戏时，该服务器将不复存在。

- 专用服务器

  也叫Dedicated-server，这种情况下将某个机器指定为游戏的服务器，没有人在这个机器上玩游戏，无需渲染图像，所以一般这种方法会有两套程序，一个是服务器运行程序，一个是客户端程序。专用服务器的最大优势在于它们适合托管在专业数据中心，并具有所需的所有可靠性和性能优势，同时还消除了低延迟优势，所以一般MMO和竞技游戏会用这种方法。

当你了解这些网络架构后，请想一下我们[之前做的](#TestMuti)，相信你会有更深的理解。

另外在实现的过程中在基础Gameplay交互（碰撞、移动、损伤）、美化效果（视觉效果和声音）以及玩家信息（HUD更新）之间进行了划分。这三者各自与网络中的特定计算机或一组计算机关联。此信息的复制过程并非完全自动化，你必须在Gameplay编程中指定要将哪些信息复制到哪些计算机。主要难点在于选择应该将哪些信息复制到哪些连接，才能为所有玩家提供一致的体验，同时还要最大限度减少信息复制量，避免网络带宽频繁饱和。<span id="NetworkTips">这里有一些优化网络和一些提示: </span>参考[网络概述|联网提示](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#networkingtips)

#### 联网提示

- 使用尽可能少的RPC和复制的蓝图函数。如果你可以改用Replicated Using（RepNotify）属性，就应该使用它。
- 少用多播函数，因为它们会为每个连接的客户端带来额外的网络流量。
- 如果你可以保证非复制的函数仅在服务器上执行，仅限服务器的逻辑不一定需要包含在服务器RPC中。
- 将可靠RPC绑定到玩家输入时需谨慎操作。玩家可能会迅速反复按键，从而使可靠RPC队列溢出。如果你要这样做，就应该创建一种机制，限制玩家可以根据输入激活RPC的频率。
- 如果RPC被特别频繁地调用，例如在Actor更新函数中，则应将RPC设为不可靠。
- 尽可能经常回收函数。一些函数可以通过调用它们以响应Gameplay逻辑来回收，也可以作为RepNotify来回收，以确保客户端和服务器有并行执行。
- 检查你的Actor的网络角色。若要在同时在服务器和客户端上激活的函数中筛选执行，这会非常有用。
- 使用 `IsLocallyControlled` 检查你的Pawn是否在本地受控制。若要根据Pawn是否对所属客户端相关而筛选执行，这会非常有用。
- 利用网络休眠。这是你可以在网络Gameplay中做出的最显著优化之一。

h





























# 额外致谢

除文章提到的，还要另外感谢他们提供的帮助

- [@DruidMechanics](https://twitter.com/DruidMechanics)
