---
layout: post
title: "联网和多人游戏"
date: 2024-4-20 09:00:00 +0800 
categories: UE
tag: Network
---
* content
{:toc #markdown-toc}

这是一篇关于UE中网络知识的文章。虚幻引擎提供的网络框架非常的强大，在简化开发者的打造网络功能流程的同时，也增加了使用的负担，但是只要我们去了解和学习，这些负担终究会变为我们站在高处的基石。

<!-- more -->

> 参考：[UE官方文档：联网和多人游戏](https://docs.unrealengine.com/4.26/zh-CN/InteractiveExperiences/Networking/)

# 一、尽早规划多人游戏

和官方文档一样，这个真的很重要，第一步就是要在项目规划时就确定好是否需要有多人游戏功能，因为在这之后构建出来的gameplay框架(可能用词不准)几乎是两种完全不同的，我就亲眼看到过一个经验不充足的开发者，在上架一个单人射击游戏后，想要加入联机功能，他在整理整个项目之后告诉我说做不出来，因为这几乎要把整个项目重新写一遍并添加新的功能。如果你真的不太清楚，那么最好是构建有网络框架的gameplay，这样即便后面不需要联机功能，也可以运行。

# 二、开始多人游戏

有些开发者喜欢先做出一些功能再深入了解，说这样脑子里有自己的印象，比直接看概念好。但是我还是要在简单的开始前说什么是多人游戏。

## 1、什么是网络多人游戏

在单人游戏中，即使你用同一台计算机多个设备输入将游戏分屏进行本地多人游戏，这种游戏不需要联网将信息传输到另一台机器上运行游戏实例，所有交互都在同一台机器上的同一场景中发生。

因此我们要说的多人游戏，是指真正的多人游戏，是网络多人游戏，他的交互发生在多个不同场景：服务器上的场景、玩家1客户端的场景、玩家2客户端的场景，等等。每台不同机器上的各场景均有各自的Actor副本。而服务器是游戏真正运行的地方，但我们要让客户端的场景看似发生了相同事件，比如：玩家1向前走了一步。因此，需要选择性地向各客户端发送信息，比如：有关玩家1移动的信息必须发送到玩家2的设备上，而玩家2也向前走了一步，那么我们也必须将玩家2移动的信息发送给玩家1的设备上。

<span id="TestMuti">那么</span>好，先在UE上看看多人游戏模式吧：[测试多人游戏](https://docs.unrealengine.com/4.26/zh-CN/InteractiveExperiences/Networking/TestMultiplayer/), [测试和调试网络游戏](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/testing-and-debugging-networked-games-in-unreal-engine?application_version=5.3)

## 2、测试多人游戏

 一方面可以先有一个小操作使读者有一个大概的印象，另一方面则是我们开发多人游戏时需要时不时的调试多人功能，如果每次都要先和其他开发者同步代码再联机测试未免有些太过繁琐，那么这里就有几种在本地进行多人游戏调试的方法。

### 1)启动独立服务器

**编辑器偏好设置(Editor Preferences)** > **关卡编辑器(Level Editor)** > **运行(Play)** > **多人游戏选项(Multiplayer Options)** > **启动独立服务器(Launch Independent Server)**设为`true`，**运行网络模式(Play Net Mode)** 选择**独立运行(Play Standalone)**，然后你找到**服务器端口(Server Port)**一般默认是`17777`这个你不需要改，然后找到**客户端玩家数量(Play Number Of Clients)**修改为`2`，你也可以尝试3或者以上的数值。ok配置完毕，这时你随意打开一个蓝图，点击运行按钮或者使用快捷键Alt+P，那么这个时候会弹出两个窗口，注意窗口上方的字你会发现有些不同，没错，一个是`Standalone 1`，一个是`Standalone 2`，这是两个独立运行的客户端，分别在命令行输入

```
open 127.0.0.1:17777
```

这时两个客户端就相见了，你可以跳一跳玩一玩。

![](../../../styles/images/Network/IndependentServer.png)

### 2)Play As Listen Server

现在我们将上述的启动独立服务器(Launch Independent Server)设为`false`，随意打开一个蓝图点击运行按钮旁边的三个点或下拉箭头，将下面的`Net Mode`设为`Play As Listen Server`，客户端数量还是2，现在点击运行。此时出现的两个客户端一个作为服务器`Server 0`，另一个则是客户端`Client 1`，哎，那么你就会问了，这个怎么是从0开始的，刚才那个怎么是从1开始的，因为上面那个还有一个你看不见的独立服务器在运行。

![](../../../styles/images/Network/PlayAsListenServer.png)

### 3)Play as Client

将Net Mode设为Play as Client运行一下看看，没错有一个隐藏服务器在运行，使用这个方法和第一种是一样的，只不过这个是自动的，按照官方说法，在编辑器的**网络模式选项（Net Mode options）**中使用**作为客户端运行（Play as Client）**或**作为侦听服务器运行（Play As Listen Server）**时，这些实例会自动通过IP地址直接相互连接。这相当于在**客户端**上运行 `open 127.0.0.1:17777` 命令，以便连接到服务器**。所以我们一般使用第2，3种方法测试，不用第一种。

### 4)Standalone Game

这个比较重要，因为在编辑器中运行（PIE）时，[服务器/客户端移动](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/travelling-in-multiplayer-in-unreal-engine?application_version=5.3)等功能存在限制。你的项目需要在独立模式下作为编辑器之外的单独进程运行，以便测试这些功能。

如果你在单独的进程下运行实例，一个实例将被视为在编辑器中运行，而其他实例将被视为独立运行。与统一运行实例相比，不论是统一在编辑器中运行还是统一独立运行，单独运行可能会导致不同的行为。例如，需要调用UEditorEngine::NetworkRemapPath函数，以便在通过网络发送的静态Actor的路径上添加或删除PIE前缀。

所以说如果某些功能在PIE中看不到，但是你感觉没问题那么就试试这个模式，可能就有效果了。

最后再看一下官方给出的[网络模式](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#networkmodes)图表

| **网络模式**       | `ENetMode`           | **说明**                                                 |
| :----------------------: | -------------------- | -------------------------------------------------- |
| **单机**          | `NM_Standalone`      | 有一个或多个本地玩家且没有联网的游戏。仍被视为服务器，因为它包含所有服务器功能，但不接受来自远程客户端的连接。此模式用于单人和本地多人游戏。此模式可根据需要同时运行服务器端和客户端逻辑。 |
| **专用服务器**     | `NM_DedicatedServer` | 没有本地玩家的服务器。服务器仅接受来自远程客户端的连接，因此为了更高效地运行，服务器放弃了图形、声音、输入和其他面向玩家的功能。此模式常用于需要更持久、安全或大规模多玩家的游戏。 |
| **监听服务器**     | `NM_ListenServer`    | 此服务器也有一个本地玩家，此玩家负责托管游戏。可供网络上的其他玩家链接。此模式常用于临时合作和竞技多人游戏。 |
| **客户端**        | `NM_Client`          | 连接到远程服务器的客户端。客户端连接到网络多人游戏会话中的监听服务器或专用服务器。客户端不运行服务器端逻辑。 |

# 三、网络概述

热身到这里想必你应该有一定的概念了，或许你还有好多疑惑，但是先从理论开始吧。[虚幻引擎网络架构](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#unrealenginenetworkingarchitecture)

## 1、网络架构

> 参考：[Game server](https://en.wikipedia.org/wiki/Game_server)

这里就开始讲解单独运行的游戏之间在网络中通信获取信息的方法。我们会讲解两种模型：对等模型(PEER-TO-PEER \ P2P)，客户端服务器模型(CLIENT-SERVER model \ C/S model)。

### 1)PEER-TO-PEER

> 参考：[Peer-to-peer](https://en.wikipedia.org/wiki/Peer-to-peer)

这个是传输信息最简单的方法之一，当玩家1移动角色时，该动作信息将直接发送给玩家2的电脑，同样玩家2移动时，也会将信息发送给玩家1，这个听起来就很好实现，但是他有一些问题，现在我们有玩家3加入游戏，每当一个玩家移动时他们都必须将这些信息发送给其他两个玩家，这样会导致有大量的网络数据传输，对于拥有很多玩家的游戏，这听起来很差。

![](../../../styles/images/Network/P2P.png)

另外这么多人的游戏实例，没有权威的版本，每个都不同，每当玩家改动任一数据，比如走一步，就会偏离本地版本的游戏，其他机器需要一定时间传播接受数据来更新游戏实例，但是谁是真正的正确的游戏实例，没人知道。

### 2)CLIENT-SERVER

> 参考：[Client-server model](https://en.wikipedia.org/wiki/Client%E2%80%93server_model)

制作多人游戏还有一种方法，这种方法也是UE使用的架构，叫做**客户端-服务器架构**，很多玩家使用不同的计算机通过网络连接到一台中央计算机。中央计算机称为**服务器**，它会托管多人游戏，而不同计算机上的其他所有玩家都作为**客户端**连接到该服务器。服务器会将游戏状态信息与每个连接的客户端共享，并为不同计算机上的所有玩家提供了彼此通信的方式。每个客户端都只会与服务器交流，因此每个客户端只需要满足发送和接收自己的信息的宽带要求即可。举个栗子：玩家1移动一步，此信息发送给服务器，服务器发送给其他客户端，这样所有人的屏幕都会更新到玩家1移动了一步。

![](../../../styles/images/Network/ClientServer.png)
[^1]: *在联网多人游戏中，游戏将在服务器与多个与之连接的客户端之间进行。服务器处理Gameplay，客户端为用户渲染游戏。*

另外UE将服务器作为游戏主机保存一个真正的**权威**游戏状态。即：使用**Authoritative Client-Server Model**，权威客户端服务器架构。(当然实现C/S并不只有这一种方法)。换句话说，服务器是多人游戏实际运行的地方，并且服务器版本是权威版本被视为唯一正确的版本。客户端各自控制它们在服务器上拥有的远程**Pawn**。客户端从其本地Pawn向其服务器Pawn发送*远程程序调用*以在游戏中执行操作。接着，服务器向每个客户端*复制*关于游戏状态的信息，例如**Actor**所在的位置，这些Actor应该具备怎样的行为，以及不同的变量应该有哪些值。然后每个客户端使用这些信息，近似模拟服务器上实际正在发生的情况。所以其实情况是这样的：玩家1按下前进按钮进行移动，实际上将移动请求发送到服务器，然后检测以确保该运动合理，然后服务器移动角色并将移动更新信息再发给所有客户端包括玩家1，从服务器到客户端的数据分发称为**复制**。当然还有一些其他细节，后面再说。

> 默认情况下，服务器不会直接将视觉效果流送到客户端显示器进行显示，服务器会将状态信息发送给客户端游戏实例，以便客户端计算机可以在自己的游戏实例中重现视觉效果。虚幻引擎提供了 **像素流送（Pixel Streaming）** 系统，用于预渲染帧和音频，以在移动端和Web浏览器上显示。更多信息请参阅[像素流送](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/pixel-streaming-in-unreal-engine?application_version=5.3)文档。
>
> 复制详情参阅：[网络概述|复制](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#replication)

要实现这种权威客户端服务器模型，并不只有一种方法，比如：

- 监听服务器
  也叫Listen-server，这种情况下，有其中一个客户端充当服务器，那么此服务器实际上正在玩游戏并且会将图像渲染到屏幕上，监听服务器的优势在于它基本上是免费的，不需要任何特殊的基础设施或提前规划即可建立，不过由于运行服务器的机器也在生成输出图像，因此性能也会降低。此外，监听服务器为直接在其上玩游戏的玩家提供了比其他作为客户端的玩家更大的延迟优势，并且当该玩家离开游戏时，该服务器将不复存在。由于 Listen-Server 在客户端本身上运行，因此其他人需要连接的 IP 是客户端的 IP。与专用服务器相比，这通常伴随着玩家没有静态IP的问题。但是，使用 OnlineSubsystem（稍后解释）可以解决更改 IP 的问题。

- 专用服务器

  也叫Dedicated-server，这种情况下将某个机器指定为游戏的服务器，没有人在这个机器上玩游戏，无需渲染图像，所以一般这种方法会有两套程序，一个是服务器运行程序，一个是客户端程序。专用服务器的最大优势在于它们适合托管在专业数据中心，并具有所需的所有可靠性和性能优势，同时还消除了低延迟优势，所以一般MMO和竞技游戏会用这种方法。

当你了解这些网络架构后，请想一下我们[之前做的](#TestMuti)，相信你会有更深的理解。

另外在实现的过程中在基础Gameplay交互（碰撞、移动、损伤）、美化效果（视觉效果和声音）以及玩家信息（HUD更新）之间进行了划分。这三者各自与网络中的特定计算机或一组计算机关联。此信息的复制过程并非完全自动化，你必须在Gameplay编程中指定要将哪些信息复制到哪些计算机。主要难点在于选择应该将哪些信息复制到哪些连接，才能为所有玩家提供一致的体验，同时还要最大限度减少信息复制量，避免网络带宽频繁饱和。<span id="NetworkTips">这里有一些优化网络和一些提示: </span>参考[网络概述|联网提示](https://dev.epicgames.com/documentation/en-us/unreal-engine/networking-overview-for-unreal-engine#networkingtips)

#### 联网提示

- 使用尽可能少的RPC和复制的蓝图函数。如果你可以改用Replicated Using（RepNotify）属性，就应该使用它。
- 少用多播函数，因为它们会为每个连接的客户端带来额外的网络流量。
- 如果你可以保证非复制的函数仅在服务器上执行，仅限服务器的逻辑不一定需要包含在服务器RPC中。
- 将可靠RPC绑定到玩家输入时需谨慎操作。玩家可能会迅速反复按键，从而使可靠RPC队列溢出。如果你要这样做，就应该创建一种机制，限制玩家可以根据输入激活RPC的频率。
- 如果RPC被特别频繁地调用，例如在Actor更新函数中，则应将RPC设为不可靠。
- 尽可能经常回收函数。一些函数可以通过调用它们以响应Gameplay逻辑来回收，也可以作为RepNotify来回收，以确保客户端和服务器有并行执行。
- 检查你的Actor的网络角色。若要在同时在服务器和客户端上激活的函数中筛选执行，这会非常有用。
- 使用 `IsLocallyControlled` 检查你的Pawn是否在本地受控制。若要根据Pawn是否对所属客户端相关而筛选执行，这会非常有用。
- 利用网络休眠。这是你可以在网络Gameplay中做出的最显著优化之一。

## 2、Network & Gameplay Framework

### Game Mode

**GameMode**用于定义游戏规则，这包括要生成哪些其他游戏框架类，如 APawn、APlayerController、APlayerState 等。当我们创建GameMode时可以继承自**AGameModeBase**和**AGameMode**。引用源码里的话就是

```c++
/**
 * GameMode is a subclass of GameModeBase that behaves like a multiplayer match-based game.
 * It has default behavior for picking spawn points and match state.
 * If you want a simpler base, inherit from GameModeBase instead.
 */
```

因此大部分虚幻引擎游戏直接继承自AGameModeBase尤其是单机游戏。对于MatchState这个功能，以后会说。另外GameMode仅在服务器上可用。客户端没有AGameModeBase类的实例，并且在尝试检索它时只会得到一个nullptr。

### Game State

GameState同样有**AGameStateBase**和**AGameState**两种类可以继承，和GameMode相似。**AGameState**类可能是服务器和客户端之间共享信息的最重要的类。GameState用于跟踪游戏/比赛的当前状态。对于多人游戏来说，这包括已连接玩家的列表(APlayerState)。此外，它会为所有客户端进行复制，因此每个人都可以访问它。这使得GameState成为多人游戏信息中最核心的类之一。GameMode会告诉我们需要击杀多少次才能获胜，而GameState则会跟踪每个玩家和/或团队当前的击杀次数！在这里存储什么信息完全由您决定。它可以是分数数组，也可以是用于跟踪团体和公会的自定义结构数组。即存储整场游戏的数据。

```c++
/**
 * GameState is a subclass of GameStateBase that behaves like a multiplayer match-based game.
 * It is tied to functionality in GameMode.
 */
```

与GameMode相比，GameState并没有给我们提供太多可供使用的功能，但它仍然允许我们创建我们的逻辑，该逻辑主要应该尝试将信息传播给客户端。

### Player State

**APlayerState**类是共享玩家信息的最重要的类。它用于保存玩家的当前信息。每个玩家都有自己的PlayerState，并且也会复制到每个人，并可用于检索和显示其他客户端上的数据。访问所有PlayerState的简单方法是使用AGameStateBase类中的PlayerArray。

```c++
/** Array of all PlayerStates, maintained on both server and clients (PlayerStates are always relevant) */
UPROPERTY(Transient, BlueprintReadOnly, Category=GameState)
TArray<TObjectPtr<APlayerState>> PlayerArray;
```

PlayerState一般用来存储各自玩家的信息，示例：

- **Player Name** - 玩家的当前名称
- **Score**- 玩家的当前分数
- **Ping** - 玩家当前的 Ping 值
- **Team ID** - 玩家队伍的 ID
- 或者其他玩家可能需要知道的其他复制信息(比如英雄联盟中你出了5个装备，那么在其他玩家的计分板里面也会在你的信息一栏中出现5个装备)

另外PlayerState还用于在无缝切换关卡和断线重连时确保数据的永存性。这个以后再说。

### Pawn

**APawn**类是玩家控制的**“AActor”**。玩家一次只能拥有一个Pawn，但可以通过取消拥有和重新拥有Pawn来轻松地在Pawn之间切换。

**Pawn大部分被复制到所有客户端。**

Pawn的子类**ACharacter**经常被使用，因为它带有一个已经联网的MovementComponent，可以处理复制玩家角色的位置、旋转等。

在多人游戏中，我们主要使用Pawn的复制部分来显示角色并与其他人共享一些信息。一个简单的例子是角色的“血量”。但我们不仅复制“血量”以使其对其他人可见，我们还复制它以便服务器对其拥有权限并且客户端无法作弊。那么你可能会问，这个血量不是玩家各自拥有的变量吗，为什么不放在PlayerState中，因为PlayerState的网络更新较慢，Health变量需要经常处理和进行网络传播放在这里不合适，放在Pawn里做成员变量即可。可以查看[网络同步入门|复制频率](https://www.cnblogs.com/lawliet12/p/17306303.html)

### Player Controller

PlayerController 可以看作是玩家的“Input”。它是玩家与服务器之间的连接。客户端的PlayerController只存在于其终端以及服务器上。客户端无法访问其他客户端的PlayerController。

**每个客户端只知道他们自己的PlayerController！服务器拥有所有客户端PlayerController的引用！**

术语“Input”并不直接意味着所有实际输入（按钮按下、鼠标移动、控制器轴等）都需要放置在玩家控制器中。将特定于 Pawn/Character 的输入 (比如：汽车的工作方式与人类不同) 放入APawn/ACharacter类中，并将适用于所有角色的输入 (甚至当角色对象无效时) 放入PlayerController中，是一种很好的做法。

节点`GetPlayerController(0)`或代码行`UGameplayStatics::GetPlayerController(GetWorld(), 0);`在服务器和客户端上的工作方式不同。

- 在 Listen-Server 上调用它将返回 Listen-Server 的 PlayerController
- 在客户端上调用它将返回客户端的 PlayerController
- 在专用服务器上调用它将返回第一个客户端的 PlayerController

客户端中除“0”之外的其他数字将不会返回其他客户端的 PlayerController，此索引旨在用于本地玩家（分屏）。

### HUD & User Widget

**AHUD**类仅在每个客户端上可用，可通过PlayerController访问。它将由PlayerController自动生成。

**UUserWidgets**用于 Epic Games 的 UI 系统，称为**UMG (Unreal Motion Graphics)**。它们继承自**Slate**，这是一种用于在 C++ 中创建 UI 的语言，也用于虚幻引擎编辑器本身。Widget仅在本地可用。它们不会复制，也不应该包含复制代码。一般它们也不包含任何游戏代码，但有些游戏可能需要它。后面会有一个小例子。

### 总结

根据前面关于虚幻引擎的服务器-客户端架构和常见类的信息，我们可以将它们分为四类：

- **Server Only**-这些对象仅存在于服务器上
- **Server & Clients**- 这些对象存在于服务器和所有客户端上
- **Server & Owning Client**- 这些对象仅存在于服务器和所属客户端上
- **Owning Client Only**-这些对象仅存在于拥有客户端上

“Owning Client”是拥有相关参与者的玩家/客户端。在后面的章节中，所有权对于“RPCs”很重要。

下面两张图展示了一些常见的类别以及它们所属的类别。

<img src="../../../styles/images/Network/CSOwnActor.png" style="zoom:80%;" />

第二张图演示了具有两个连接客户端的专用服务器的示例。

<img src="../../../styles/images/Network/CSOwnActor.jpg" style="zoom:50%;" title="具有两个连接客户端的专用服务器中的类的维恩图示例。"/>

## 3、复制

之前说到过复制，但没有详细展开，这个是非常重要的内容因此拿了出来。**复制(Replication)**是指权威服务器将状态数据发送到连接的客户端的过程。如前所述，真正的游戏状态存在于服务器上。连接的客户端会将此状态 *复制* 到本地，并渲染图形和音频，以便客户端可以与其他客户端通信并参与游戏。如果正确配置了复制，不同计算机的游戏实例会同步，并且Gameplay会流畅运行。主要使用Actor和Actor派生的类通过UE中的网络连接复制其状态。`AActor` 是可以在关卡中放置或生成的对象的基类，也是UE的 `UObject` 继承层级中第一个支持用于网络的类。

`UObject` 派生的类也可以复制，但必须作为复制的子对象附加到Actor才能恰当复制。UActorComponent就是支持通过AActor复制且不需要我们做太多额外工作的UObjects的一个很好的例子。<span id="Replication">查看</span>[复制子对象](#RepUObject)

之前提到的所有类都从AActor继承，使其能够在需要时复制属性。尽管并非所有类都以相同的方式执行此操作。例如，AGameMode根本不复制，只存在于服务器上。AHUD只存在于客户端上，也不复制。

可以在 AActor 子类的类默认值/构造函数中激活复制：(只有激活复制，属性复制和RPC等有关网络的功能才可调用)

```c++
ATestActor::ATestActor()
{
    bReplicates = true;//这个变量在蓝图中的细节面板中的Replication中可以找到并更改，蓝图中也可以调用SetReplicates(true);
	//bReplicateMovement = true;在5.3中是私有变量应该调用SetReplicateMovement(bool);
}
void ATestActor::BeginPlay()
{
	Super::BeginPlay();

	SetReplicateMovement(true);//并非所有Actor都需要复制移动。
}
```

如果Actor由服务器生成，则“bReplicates”设置为**TRUE**的Actor将生成并在所有客户端上复制。并且**仅**当由服务器生成时。如果客户端生成此Actor，则该Actor将**仅存**在于该客户端上。

> <font color='red'>注意</font>：一旦为复制注册了属性，就不能将其注销。被设置需要复制的属性会在对象的生命周期内复制。复制系统嵌入了尽可能多的信息，以便系统可以跨连接中共享同一个属性集的工作，从而节省计算时间。

### 属性复制

在多人游戏中，你的虚幻引擎类中可能有需要复制的属性。虚幻引擎Actor使用 `Replicated` 和 `ReplicatedUsing` 元数据说明符维护所有[属性](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-uproperties?application_version=5.3)的列表。在多人Gameplay中，当属性被带有 `Replicated` 或 `ReplicatedUsing` 元数据说明符标记时，服务器会在复制的属性每次更改其值时向每个连接的客户端发送更新。每个客户端会将更新的值应用到其本地版本的Actor。

`Replicated` 属性为属性复制提供了指定特定条件的选项，将属性复制限制在特定连接上。你也可以设置自定义复制条件，为属性复制定义自己的逻辑。`ReplicatedUsing` 属性需要你提供RepNotify函数，当相关属性被复制时，客户端就会调用该函数。你还可以使用 `NotReplicated` 说明符指定 *不* 复制的属性。此说明符可能一开始看起来没什么用，但在将要复制的结构体中某个属性设置为不复制时非常有用。

#### 1)为属性添加Replicated

`TestActor.h`

```c++
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "TestActor.generated.h"

UCLASS()
class NETWORKTEACHING_API ATestActor : public AActor
{
	GENERATED_BODY()
	
public:	
	ATestActor();
	virtual void Tick(float DeltaTime) override;
	// 重载复制属性函数
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

	//耐久，复制
	UPROPERTY(Replicated)
	uint32 Durability;
protected:
	virtual void BeginPlay() override;
};
```

`TestActor.cpp`

```c++
#include "TestActor.h"

#include "Net/UnrealNetwork.h"

ATestActor::ATestActor()
{
	PrimaryActorTick.bCanEverTick = false;

	bReplicates = true;
}

void ATestActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	// 添加要为派生的类复制的属性
	DOREPLIFETIME(ATestActor, Durability);
}
```

蓝图就比较简单了：点击Replicated即可

![](../../../styles/images/Network/VarSetRep.png)

#### 2)为属性添加ReplicatedUsing

如上所示，你可以使用 `UPROPERTY` 宏中的 `Replicated` 说明符复制Actor属性。你可以使用 `ReplicatedUsing` 说明符在每次复制变量时执行特定操作。要在每次复制你的属性时执行操作，你可以使用 `ReplicatedUsing` 说明符和相关联的**RepNotify**。**RepNotify** 是复制带 `ReplicatedUsing` 说明符的属性时对客户端调用的 `OnRep_` 函数。如果你在C++中声明 `OnRep_` 函数<font color=red>必须为该函数添加“UNFUNCTION()”宏</font>

蓝图点击RepNotify即可，会自动创建RepNotify函数

`ANetworkTeachingCharacter.h`

```c++
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Logging/LogMacros.h"
#include "NetworkTeachingCharacter.generated.h"

DECLARE_LOG_CATEGORY_EXTERN(LogTemplateCharacter, Log, All);

UCLASS(config=Game)
class ANetworkTeachingCharacter : public ACharacter
{
	GENERATED_BODY()

public:
	ANetworkTeachingCharacter();
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
	// 要使用RepNotify复制的属性
	UPROPERTY(ReplicatedUsing=OnRep_HealthUpdate)
	int32 Health;
	// Health的关联RepNotify
	UFUNCTION()
	void OnRep_HealthUpdate();
};
```

`ANetworkTeachingCharacter.cpp`

```c++
#include "NetworkTeachingCharacter.h"

#include "Net/UnrealNetwork.h"

DEFINE_LOG_CATEGORY(LogTemplateCharacter);

ANetworkTeachingCharacter::ANetworkTeachingCharacter()
{
	bReplicates = true;
}

void ANetworkTeachingCharacter::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(ANetworkTeachingCharacter, Health);
}

void ANetworkTeachingCharacter::OnRep_HealthUpdate()
{
	UE_LOG(LogTemplateCharacter, Warning, TEXT(__FUNCTION__))
}
```

另外RepNotify函数可以携带参数有两种：

`DerivedActor.h`

```c++
#pragma once 
 
#include "DerivedActor.generated.h"
 
UCLASS()
class ADerivedActor : public AActor
{
	GENERATED_BODY()
 
public:
 
	// 使用OnRep_Value复制的属性
	UPROPERTY(ReplicatedUsing=OnRep_Value)
	int32 HealthValue1;
 
	// 使用OnRep_ConstRef复制的属性
	UPROPERTY(ReplicatedUsing=OnRep_ConstRef)
	int32 HealthValue2;
 
	// 使用OnRep_NoParam复制的属性
	UPROPERTY(ReplicatedUsing=OnRep_NoParam)
	int32 HealthValue3;
 
	// 要传递最后一个值的副本的签名
	UFUNCTION()
	void OnRep_Value(int32 LastHealthValue);
 
	// 要传递常量引用的签名
	UFUNCTION()
	void OnRep_ConstRef(const int32& LastHealthValue);
 
	// 派生的Actor构造函数
	ADerivedActor();
};
```

`DerivedActor.cpp`

```c++
#include "DerivedActor.h"
#include "Net/UnrealNetwork.h"
 
ADerivedActor::ADerivedActor()
{
	bReplicates = true;
}
 
void ADerivedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	// 调用Super
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 
	// 添加要为派生的类复制的属性
	DOREPLIFETIME(ADerivedActor, HealthValue1);
	DOREPLIFETIME(ADerivedActor, HealthValue2);
}
 
void ADerivedActor::OnRep_Value(int32 LastHealthValue)
{
	UE_LOG(LogTemp, Log, TEXT("OnRep_Value with value. Last value: %d"), LastHealthValue)
	// 添加自定义OnRep逻辑
}
 
void ADerivedActor::OnRep_ConstRef(const int32& LastHealthValue)
{
	UE_LOG(LogTemp, Log, TEXT("OnRep_ConstRef with const ref. Last value: %d"), *LastHealthValue)
	// 添加自定义OnRep逻辑
}
```

##### C++和蓝图中RepNotify的差异

蓝图和 C++ 处理“rep notification”概念的一个关键区别是，在蓝图中，复制的属性上的 `Set` 节点会自动调用该属性的RepNotify函数在 C++ 中，服务器*不会*自动调用RepNotify函数，只有客户端在获取更新时才会这样做。如果希望服务器调用该函数，则必须手动执行。一般来说，按引用接受属性的蓝图宏和函数不调用RepNotify，即使它们修改了值也是如此。比如蓝图中的`++`节点

此外，每当更改`Health`或其他复制变量时，都需要确保仅在服务器上进行此操作。用于检查权限的蓝图宏节点的 C++ 等效项是：

```c++
if (GetLocalRole() == ROLE_Authority)
```

所以可能的情况是

```c++
if (GetLocalRole() == ROLE_Authority)
{
    --Health;
    OnRep_HealthUpdate();
}
```

#### 3)为属性添加NotReplicated

如之前所述， `NotReplicated` 说明符可被用于标记要复制的结构体中不需复制的属性。以下代码片段展示了如何在要复制的结构体中不复制某个属性。

`DerivedActor.h`

```c++
#pragma once 
 
#include "DerivedActor.generated.h"
 
USTRUCT()
struct FMyStruct
{
	GENERATED_BODY()
 
	UPROPERTY()
	int32 ReplicatedProperty;
 
	// 不复制，尽管复制了它所在的结构体
	UPROPERTY(NotReplicated)
	int32 NotReplicatedProperty;
};
 
UCLASS()
class ADerivedActor : public AActor
{
	GENERATED_BODY()
 
public:
	UPROPERTY(Replicated)
	FMyStruct ReplicatedStruct;
 
	// 派生的Actor构造函数
	ADerivedActor();
};
```

`DerivedActor.cpp`

```c++
#include "DerivedActor.h"
#include "Net/UnrealNetwork.h"
 
ADerivedActor::ADerivedActor(const class FPostConstructInitializeProperties & PCIP) : Super(PCIP)
{
	bReplicates = true;
}
 
void ADerivedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 
	DOREPLIFETIME(ADerivedActor, ReplicatedStruct);
}
```

### 条件复制

要更精细地控制属性的复制方式，你可以使用复制条件。默认情况下，每个复制的属性仅在它发生更改时复制。未发生更改的属性不会复制，因此不会占用宝贵的带宽。

其他与上述没太大区别，只是使用不一样的宏如：

`DerviedActor.cpp`

```c++
#include "DerivedActor.h"
#include "Net/UnrealNetwork.h"
 
void ADerivedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	// 调用Super
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 
	// 添加带条件的属性复制
	DOREPLIFETIME_CONDITION(ADerivedActor, Health, COND_OwnerOnly);
}
```

或者

```c++
#include "DerivedActor.h"
#include "Net/UnrealNetwork.h"
 
void ADerivedActor::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	// 调用Super
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 
	// 添加带条件的属性复制
	/** 	此项用于总是执行RepNotify
	*	在每次复制属性时在客户端上调用关联的OnRep
	*/
	DOREPLIFETIME_CONDITION_NOTIFY(ADerivedActor, Health, REPNOTIFY_Always);
 
	/** 	此项用于仅在属性更改时执行RepNotify
	*	仅在属性更改时在客户端上调用关联的OnRep
	*/
	DOREPLIFETIME_CONDITION_NOTIFY(ADerivedActor, Health, REPNOTIFY_OnChanged);
}
```

蓝图则在细节面板中Replication下面的位置：`Replication Condition`

下表为属性复制条件列表：

| **条件**                          | **说明**                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| `COND_None`                       | 没有条件，一旦更改即复制。                                   |
| `COND_InitialOnly`                | 仅尝试在初始系列上复制。                                     |
| `COND_OwnerOnly`                  | 仅复制到Actor的所有者。                                      |
| `COND_SkipOwner`                  | 复制到除Actor的所有者之外的每个连接。                        |
| `COND_SimulatedOnly`              | 复制到模拟的Actor。                                          |
| `COND_AutonomousOnly`             | 仅复制到自主Actor。                                          |
| `COND_SimulatedOrPhysics`         | 复制到模拟的或 `bRepPhysics` Actor。                         |
| `COND_InitialOrOwner`             | 在初始系列上复制，或复制到Actor的所有者。                    |
| `COND_Custom`                     | 没有特定条件，但能够打开或关闭。请参阅[自定义属性复制](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/replicate-actor-properties-in-unreal-engine?application_version=5.3#自定义属性复制)了解更多信息。 |
| `COND_ReplayOrOwner`              | 仅复制到重播连接或Actor的所有者。                            |
| `COND_ReplayOnly`                 | 仅复制到重播连接。                                           |
| `COND_SimulatedOnlyNoReplay`      | 仅复制到模拟的Actor，但不复制到重播连接。                    |
| `COND_SimulatedOrPhysicsNoReplay` | 复制到模拟的或 `bRepPhysics` Actor，但不复制到重播连接。     |
| `COND_SkipReplay`                 | 不复制到重播连接。                                           |
| `COND_Dynamic`                    | 在运行时重载条件。默认为总是复制，除非你将其重载为新条件。   |
| `COND_Never`                      | 从不复制。                                                   |

下表描述了虚幻引擎中可用的属性复制宏，以及：

- 调用宏的函数。
- 关联的 `FRepPropertyDescriptor` 是在编译时还是运行时构造。
- 宏是否适用于数组。

| **宏**                                            | **说明**                                                     | **在何处调用宏**             | **编译时或运行时** | **适用于数组** |
| ------------------------------------------------- | ------------------------------------------------------------ | ---------------------------- | ------------------ | -------------- |
| `DOREPLIFETIME`                                   | 复制不带条件或自定义条件的属性。                             | `GetLifetimeReplicatedProps` | 运行时             | 是             |
| `DOREPLIFETIME_WITH_PARAMS`                       | 复制带控制其复制方式的 `FDoRepLifetimeParams` 结构体的属性。 | `GetLifetimeReplicatedProps` | 运行时             | 是             |
| `DOREPLIFETIME_WITH_PARAMS_FAST`                  | 复制带控制其复制方式的 `FDoRepLifetimeParams` 结构体的属性。 | `GetLifetimeReplicatedProps` | 编译时             | 否             |
| `DOREPLIFETIME_WITH_PARAMS_FAST_STATIC_ARRAY`     | 复制带控制其复制方式的 `FDoRepLifetimeParams` 结构体的属性。 | `GetLifetimeReplicatedProps` | 编译时             | 是             |
| `DOREPLIFETIME_CONDITION`                         | 复制带 `ELifetimeCondition` 的属性。                         | `GetLifetimeReplicatedProps` | 运行时             | 是             |
| `DOREPLIFETIME_CONDITION_NOTIFY`                  | 复制带 `ELifetimeRepNotifyCondition` 的属性。                | `GetLifetimeReplicatedProps` | 运行时             | 是             |
| `DOREPLIFETIME_ACTIVE_OVERRIDE`                   | 复制带自定义条件的属性。必须伴随对 `DOREPLIFETIME_CONDITION(<CLASS>, <PROPERTY>, COND_Custom)` 的调用。 | `PreReplication`             | 运行时             | 是             |
| `DOREPLIFETIME_ACTIVE_OVERRIDE_FAST`              | 复制带自定义条件的属性。必须伴随对 `DOREPLIFETIME_CONDITION(<CLASS>, <PROPERTY>, COND_Custom)` 的调用。 | `PreReplication`             | 编译时             | 否             |
| `DOREPLIFETIME_ACTIVE_OVERRIDE_FAST_STATIC_ARRAY` | 复制带自定义条件的属性。必须伴随对 `DOREPLIFETIME_CONDITION(<CLASS>, <PROPERTY>, COND_Custom)` 的调用。 | `PreReplication`             | 编译时             | 是             |

> 如果你想更好地控制属性的复制方式，请使用相应的 `DOREPLIFETIME_WITH_PARAMS` 宏指定 `FDoRepLifetimeParams` 结构体。请记住，控制越多也意味着开销越大，请用最少的信息实现所需最大程度的控制。一般用不到。你可以在 `Engine/Source/Runtime/Engine/Public/Net/UnrealNetwork.h` 中找到这些宏的定义。
>
> 详情请参阅：[复制Actor属性|复制条件引用](https://dev.epicgames.com/documentation/en-us/unreal-engine/replicate-actor-properties-in-unreal-engine#replicationconditionreference)和[属性复制引用](https://dev.epicgames.com/documentation/en-us/unreal-engine/replicate-actor-properties-in-unreal-engine#propertyreplicationreference)

### 复制子对象

了解如何复制从<span id="RepUObject">UObject</span>派生的类及其包含的复制属性。(如果你是从上面跳转来的，[想回去](#Replication))

> 原文：[复制子对象](https://dev.epicgames.com/documentation/en-us/unreal-engine/replicated-subobjects-in-unreal-engine)
>

操作例子1：

```c++
class AMyActor : public AActor
{
    UPROPERTY(Replicated)
    UMySubObjectClass* MySubObject;
}

class UMySubObjectClass : public UObject
{
    UPROPERTY(Replicated)
    int32 Counter = 0;
}

void AMyActor::CreateMyClass()
{
    MySubObject = NewObject<UMySubObjectClass>();
    MySubObject->Counter = 10;
}

void AMyActor::ReplicateSubobjects(...)
{
    Super::ReplicateSubobjects(...);
    Channel->ReplicateSubobject(MySubObject); // 这里变为子对象
}
```

在上方代码示例中，Actor使 `MySubObject` 的内容成为了 `ReplicateSubobjects` 函数中的子对象。在该阶段，指针可进行net引用。然后，`Counter` 变量会在每次复制Actor时复制到客户端。如果我们没有通过 `Channel->ReplicateSubobject(MySubObject)` 使 `MySubObject` 成为子对象，`MySubObject` 变量在客户端上始终会是 `null`。

操作例子2：以下代码示例概述了如何启用注册子对象列表。(**注册子对象列表概述**：Actor现在有方法将子对象注册到所属Actor或Actor组件上的列表，并由Actor通道自动处理这些注册子对象的复制工作。注册子对象列表允许在注册子对象时为其指定 ELifetimeCondition。该过程可更好地控制何时将子对象复制到何处，而无需用户在 ReplicateSubobjects 中实现此逻辑。此外，Actor也无需实现虚拟函数 AActor::ReplicateSubobjects 并手动复制单独的子对象。)

```c++
AMyActor::AMyActor()
{
    bReplicateUsingRegisteredSubObjectList = true;
}

void AMyActor::CleanupSubobject()
{
    if (MySubobject)
    {
        RemoveReplicatedSubobject(MySubObject);
    }
}

void AMyActor::CreateMyClass()
{
    CleanupSubobject();

    MySubObject= NewObject<UMySubObjectClass>();
    MySubObject->Counter = 10;
    AddReplicatedSubObject(MySubObject);
}

void AMyActor::CreateMyDerivedClass()
{
    CleanupSubobject();

    MySubObject = NewObject<UMyDerivedSubObjectClass>();
    AddReplicatedSubObject(MySubObject);
}
```

在 `ReadyForReplication`、`BeginPlay` 中或在创建新的子对象时调用 `AddReplicatedSubObject` 。

在Actor组件类中，`ReadyForReplication` 在 `InitComponent` 和 `BeginPlay` 之间调用。这里注册组件后，该组件就可以在组件的 `BeginPlay` 中及早调用远程程序调用（RPC）。

每当修改或删除子对象时，请调用 `RemoveReplicatedSubObject` 。如上例代码`CleanupSubobject()`

> <font color=red>这最后一步非常重要。除非删除引用，否则列表仍包含指向已更改或标记为破坏的子对象的原始指针。因此，这会在对象被垃圾回收之后导致崩溃。</font>

### 复制Actor组件

```c++
ELifetimeCondition AMyWeaponClass::AllowActorComponentToReplicate(const UActorComponent* ComponentToReplicate) const
{
    // Do not replicate some components while the object is on the ground.
    if (!bIsInInventory)
    {
        if (IsA<UDamageComponent>(ComponentToReplicate))
        {
            return COND_Never;
        }
    }
    Super::AllowActorComponentToReplicate(ComponentToReplicate);
}

void AMyWeaponClass::OnPickup()
{
    // Now replicate the component to all
    SetReplicatedComponentNetCondition(UDamageComponent, COND_None);
    bIsInInventory = true;
}
```

在上面的例子中，所属Actor类是 `AMyWeaponClass` 。我们需要根据武器当前是否在Actor的物品栏中，来设置 `UActorComponent ComponentToReplicate` 的复制条件。为完成该操作，所属Actor类 `AMyWeaponClass` 实现了 `AllowComponentToReplicate` 。

武器在地面时，它不在Actor的物品栏中。因此，我们不希望复制伤害组件。这种情况下返回的 `ELifetimeCondition` 是 `COND_Never` ，它会指定永不复制这些组件。我们想更改伤害组件的条件时，例如武器被捡起时，会直接调用 `SetReplicatedComponentCondition` ，将复制条件设置为 `COND_None` ，这表示始终会复制组件。

> 注：所属组件必须在检查其复制子对象的条件之前复制到连接。例如，如果子对象有 `COND_OwnerOnly` 条件，当它注册到使用 `COND_SkipOwner` 条件的组件时，绝不会复制该子对象。
>

## 4、RPC

RPC （远程过程调用 / **Remote Procedure Calls / RPCs**）是在本地调用但在其他机器上远程执行的函数。RPC 函数非常有用，可允许客户端或服务器通过网络连接相互发送消息。

这些功能的主要作用是执行那些不可靠的短暂/修饰性游戏事件。这其中包括播放声音、生成粒子或执行动画之类的事件。

在使用 RPC 时，还必须要了解 [所有权的工作方式](https://dev.epicgames.com/documentation/zh-cn/unreal-engine/actor-owner-and-owning-connection-in-unreal-engine?application_version=5.3)，因为所有权决定了 RPC 远程执行的位置。后面会说。

### RPC 的类型

下表概述了三种不同类型的 RPC：

| **元数据说明符** | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| `Client`         | RPC 在该参与者的拥有客户端连接上执行。                       |
| `Server`         | RPC 在服务器上执行。                                         |
| `NetMulticast`   | RPC 在服务器和该参与者相关的所有当前连接的客户端上执行。从客户端调用的 RPC 仅在本地执行。 |

### RPC的使用

`DerivedActor.h`

```c++
#pragma once

#include "DerivedActor.generated.h"

UCLASS()
class ADerivedActor : public AActor
{
 GENERATED_BODY()

public:

 // Client RPC Function
 UFUNCTION(Client)
 void ClientRPC();

 // Server RPC Function
 UFUNCTION(Server)
 void ServerRPC();

 // Multicast RPC Function
 UFUNCTION(NetMulticast)
 void MulticastRPC();
}
```

> 按照惯例，在 RPC 函数名称前面加上 RPC类型：
>
> - `Client`用于客户端 RPC 功能。
> - `Server`用于服务器 RPC 功能。
> - `Multicast`用于网络多播 RPC 功能。
>
> 这对于一眼判断多人游戏会话期间该函数调用适用于哪些机器很有用。

`DerivedActor.cpp`

```c++
#include "DerivedActor.h"

void ADerivedActor::ClientRPC_Implementation()
{
 // This log will print on every machine that executes this function.
 UE_LOG(LogTemp, Log, TEXT("ClientRPC executed."))
}

void ADerivedActor::ServerRPC_Implementation()
{	
 // This function only executes if ServerRPC_Validate returns true.
 // This log will print on every machine that executes this function.
 UE_LOG(LogTemp, Log, TEXT("ServerRPC executed."))
}

void ADerivedActor::MulticastRPC_Implementation()
{
 // This log will print on every machine that executes this function.
 UE_LOG(LogTemp, Log, TEXT("MulticastRPC executed."))	
}
```

调用RPC函数

```c++
// Call from client to run on server
ADerivedClientActor* MyDerivedClientActor;
MyDerivedClientActor->ServerRPC();

// Call from server to run on client
ADerivedServerActor* MyDerivedServerActor;
MyDerivedServerActor->ClientRPC();

// Call from server to run on server and all relevant clients
ADerviedMultiActor* MyDerivedMultiActor;
MyDerievedMultiActor->MulticastRPC();
```

> `Client`和`Server`RPC 都是单播 RPC。*单播*RPC 之所以如此命名，是因为它们在一台机器上执行。`NetMulticast`*多播*RPC是因为它可以在多台机器上执行。

### RPC调用关系

首先必须满足一些要求才能充分发挥 RPC 的作用：

1. 它们必须从 Actor 上调用。
2. Actor 必须被复制。
3. 如果 RPC 是从服务器调用并在客户端上执行，则只有实际拥有这个 Actor 的客户端才会执行函数。
4. 如果 RPC 是从客户端调用并在服务器上执行，客户端就必须拥有调用 RPC 的 Actor。
5. 多播 RPC 则是个例外：
   - 如果它们是从服务器调用，服务器将在本地和所有已连接的客户端上执行它们。
   - 如果它们是从客户端调用，则只在本地而非服务器上执行。
   - 现在，我们有了一个简单的多播事件限制机制：在特定 Actor 的网络更新期内，多播函数将不会复制两次以上。

下面的表格根据执行调用的 actor 的所有权（最左边的一列），总结了特定类型的 RPC 将在哪里执行。

#### 从服务器调用的 RPC

| Actor 所有权           | 未复制         | `NetMulticast`             | `Server`       | `Client`                    |
| ---------------------- | -------------- | -------------------------- | -------------- | --------------------------- |
| **Client-owned actor** | 在服务器上运行 | 在服务器和所有客户端上运行 | 在服务器上运行 | 在 actor 的所属客户端上运行 |
| **Server-owned actor** | 在服务器上运行 | 在服务器和所有客户端上运行 | 在服务器上运行 | 在服务器上运行              |
| **Unowned actor**      | 在服务器上运行 | 在服务器和所有客户端上运行 | 在服务器上运行 | 在服务器上运行              |

#### 从客户端调用的 RPC

| Actor 所有权                    | 未复制                   | `NetMulticast`           | `Server`       | `Client`                 |
| ------------------------------- | ------------------------ | ------------------------ | -------------- | ------------------------ |
| **Owned by invoking client**    | 在执行调用的客户端上运行 | 在执行调用的客户端上运行 | 在服务器上运行 | 在执行调用的客户端上运行 |
| **Owned by a different client** | 在执行调用的客户端上运行 | 在执行调用的客户端上运行 | 丢弃           | 在执行调用的客户端上运行 |
| **Server-owned actor**          | 在执行调用的客户端上运行 | 在执行调用的客户端上运行 | 丢弃           | 在执行调用的客户端上运行 |
| **Unowned actor**               | 在执行调用的客户端上运行 | 在执行调用的客户端上运行 | 丢弃           | 在执行调用的客户端上运行 |

> 更详细的表格请参阅：[Matrix of RPC Execution](https://dev.epicgames.com/documentation/en-us/unreal-engine/remote-procedure-calls-in-unreal-engine#matrixofrpcexecution)

### 可靠性

虚幻引擎中的 RPC 被标记为可靠或不可靠：

| **元数据说明符** | **描述**                                                     | **执行顺序**   |
| ---------------- | ------------------------------------------------------------ | -------------- |
| `Reliable`       | 此 RPC 会重新发送，直到接收方确认。所有后续 RPC 执行都会暂停，直到此 RPC 得到确认。 | 保证按序排列。 |
| `Unreliable`     | 如果数据包被丢弃，则不会再次执行此 RPC。                     | 沒有顺序保证。 |

> 默认情况下，RPC 是不可靠的。可靠的 RPC 需要额外的带宽，因此请谨慎使用它们。虚幻引擎 (UE) 的网络复制使用可靠和不可靠通信方法的组合在服务器和连接的客户端之间传输信息。*可靠*通信会持续发送，暂停所有其他网络通信，直到接收机器确认。如果接收机器未确认接收，则在当前网络周期内发送不可靠通信，并且不会重新发送。虚幻引擎中的复制系统尽可能可靠地执行 RPC，因此可以构建游戏系统而不必担心网络副作用。
>
> 不要将每个 RPC 都标记为可靠！只应对偶尔调用的 RPC 执行此操作，并且需要它们到达目的地。在 Tick 上调用可靠的 RPC 可能会产生副作用，例如填充可靠缓冲区，这可能导致其他属性和 RPC 不再被处理。
>
> 有关虚幻引擎中复制执行顺序保证的更多信息，请参阅[复制对象执行顺序](https://dev.epicgames.com/documentation/en-us/unreal-engine/replicated-object-execution-order-in-unreal-engine?application_version=5.3)文档。

#### 指定 RPC 可靠性

要指定 RPC 的可靠性，为 RPC 添加适当的元数据说明符：

`DerivedActor.h`

```c++
#pragma once

#include "DerivedActor.generated.h"

UCLASS()
class ADerivedActor : public AActor
{
    GENERATED_BODY()

public:	
    // Client Default Unreliable RPC Function
    UFUNCTION(Client)
    void ClientDefaultUnreliableRPC();

    // Client Unreliable RPC Function
    UFUNCTION(Client, Unreliable)
    void ClientUnreliableRPC();

    // Client Reliable RPC Function
    UFUNCTION(Client, Reliable)
    void ClientReliableRPC();
}
```

### Server RPC 验证

Server RPC 验证实施*信任和验证*网络策略。服务器信任客户端与其通信的信息，但始终验证此信息是否遵循服务器上游戏定义的规则和约束。(信任这部分后面再说)

可以使用`WithValidation` `UFUNCTION`元数据标记Server RPC，并定义相应的Server RPC 验证函数。验证函数的名称与 RPC 函数相同，但在函数名称末尾附加了`_Validate` 。返回类型为布尔值，它采用与其关联的 RPC 函数相同的参数。验证函数可帮助服务器根据你定义的验证逻辑确定是否应该运行 RPC。当客户端发出调用以执行Server RPC时，将首先在服务器上调用验证函数。

根据验证函数的输出，会发生以下情况：

- 如果输入通过验证，则调用实现。
- 如果输入验证失败，调用客户端将与服务器<font color=red>断开连接(被踢出服务器)</font>。

#### 添加验证实施

要为 RPC 添加验证功能，请按照以下步骤操作：

`DerivedActor.h`

```c++
#pragma once

#include "DerivedActor.generated.h"

UCLASS()
class ADerivedActor : public AActor
{
 GENERATED_BODY()

public:
 UPROPERTY(Replicated)
 int32 Health;
 int32 MAXHEALTH = 100;

 // Server Unreliable RPC Function
 UFUNCTION(Server, Unreliable, WithValidation)
 void ServerUnreliableRPC(int32 RecoverHealth); 
}
```

`DerivedActor.cpp`

```c++
#include "DerivedActor.h"

// RPC Validation Implementation
bool ServerUnreliableRPC_Validate(int32 RecoverHealth)
{
 if (Health + RecoverHealth > MAXHEALTH)
 {
     return false;
 }
return true;
}

// RPC Implementation
void ServerUnreliableRPC_Implementation(int32 RecoverHealth)
{
 Health += RecoverHealth;
}
```

### 蓝图中的 RPC

C++ 中的 RPC 所具有的相同类型的 RPC、可靠性选项和执行逻辑也存在于 Blueprint 中的 RPC 中。要创建复制的 Blueprint 事件，请按照以下步骤操作：

1. 创建或打开蓝图 Actor 或 Actor 派生类。
2. 确保蓝图的**详细信息面板**中的**复制**设置为**True**。
3. 右键单击并选择**添加事件>添加自定义事件…(Add Custom Event...)**
4. 单击**CustomEvent**节点以调出**详细信息面板**。
5. **可以在“详细信息面板”>“图表”>“复制”**下选择事件是否复制、使用哪种复制类型以及是否可靠。

![](../../../styles/images/Network/SetRPC.png)

6. 选择所需的设置后，在蓝图中定义 RPC 功能即可。



































# 额外致谢

除文章提到的，还要另外感谢他们提供的帮助

- [@DruidMechanics](https://twitter.com/DruidMechanics)
